using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using ClangAggregator;
using ClangAggregator.Types;

namespace ClangCaster
{
    abstract class CSUserTypeGeneratorBase
    {
        protected DotLiquid.Template m_template;

        abstract protected string TemplateSource { get; }

        protected CSUserTypeGeneratorBase()
        {
            m_template = DotLiquid.Template.Parse(TemplateSource);
        }
    }

    /// <summary>
    /// CSharpのコードを生成する
    /// </summary>
    class CSGenerator
    {
        public const string COMMNET = "// This source code was generated by ClangCaster";
        const string BEGIN = @"using System;
using System.Runtime.InteropServices;

namespace {{ ns }}
{
    public static partial class {{ dll }}
    {
";
        const string END = @"   }
}
";

        static string ExportFile(DirectoryInfo directory, NormalizedFilePath f)
        {
            var stem = Path.GetFileNameWithoutExtension(f.Path);
            return Path.Combine(Path.Combine(directory.FullName, $"{stem}.cs"));
        }


        static string ExportDir(DirectoryInfo directory, NormalizedFilePath f)
        {
            var stem = Path.GetFileNameWithoutExtension(f.Path);
            return Path.Combine(Path.Combine(directory.FullName, stem));
        }

        public void Export(IDictionary<NormalizedFilePath, ExportSource> map, DirectoryInfo dst, string ns, string dll)
        {
            DotLiquid.Template.RegisterSafeType(typeof(TypeReference), new string[] { "Type" });
            DotLiquid.Template.RegisterSafeType(typeof(FileLocation), new string[] { "Path", "Line" });
            DotLiquid.Template.RegisterSafeType(typeof(NormalizedFilePath), new string[] { "Path" });

            var enumTemplate = new CSEnumGenerator();
            var structTemplate = new CSStructGenerator();
            var functionTemplate = new CSFunctionGenerator();
            var beginTemplate = DotLiquid.Template.Parse(BEGIN);
            var endTemplate = DotLiquid.Template.Parse(END);
            foreach (var (sourcePath, exportSource) in map)
            {
                Console.WriteLine(sourcePath);
                var dir = ExportDir(dst, sourcePath);

                if (exportSource.EnumTypes.Any())
                {
                    var enumsDir = new DirectoryInfo(Path.Combine(dir, $"enums"));
                    enumsDir.Create();
                    foreach (var enumType in exportSource.EnumTypes)
                    {
                        var path = new FileInfo(Path.Combine(enumsDir.FullName, $"{enumType.Name}.cs"));
                        using (var s = new FileStream(path.FullName, FileMode.Create))
                        using (var w = new StreamWriter(s))
                        {
                            w.Write(enumTemplate.Render(ns, enumType));
                            w.WriteLine(CSGenerator.COMMNET);
                        }
                    }
                }

                if (exportSource.StructTypes.Any())
                {
                    var structsDir = new DirectoryInfo(Path.Combine(dir, $"structs"));
                    structsDir.Create();
                    foreach (var structType in exportSource.StructTypes)
                    {
                        var path = new FileInfo(Path.Combine(structsDir.FullName, $"{structType.Name}.cs"));
                        using (var s = new FileStream(path.FullName, FileMode.Create))
                        using (var w = new StreamWriter(s))
                        {
                            w.WriteLine(CSGenerator.COMMNET);
                            w.Write(structTemplate.Render(ns, structType));
                        }
                    }
                }

                if (exportSource.FunctionTypes.Any())
                {
                    var path = ExportFile(dst, sourcePath);
                    using (var s = new FileStream(path, FileMode.Create))
                    using (var w = new StreamWriter(s))
                    {
                        w.WriteLine(COMMNET);

                        // BEGIN
                        w.Write(beginTemplate.Render(DotLiquid.Hash.FromAnonymousObject(
                            new
                            {
                                ns = ns,
                                dll = dll,
                            }
                        )));

                        foreach (var functionType in exportSource.FunctionTypes)
                        {
                            w.Write(functionTemplate.Render(dll, functionType));
                        }

                        // END
                        w.Write(endTemplate.Render(DotLiquid.Hash.FromAnonymousObject(
                            new
                            {
                            }
                        )));
                    }
                }
            }

            // csproj
            {
                var csproj = Path.Combine(dst.FullName, $"{dst.Name}.csproj");
                using (var s = new FileStream(csproj, FileMode.Create))
                using (var w = new StreamWriter(s))
                {
                    w.WriteLine(@"<Project Sdk=""Microsoft.NET.Sdk"">

  <PropertyGroup>
    <TargetFramework>netstandard2.0</TargetFramework>
  </PropertyGroup>

</Project>");
                }
            }
        }
    }
}
